SELECT *
FROM CONTACTS
;

-- 고객 테이블에서 고객 아이디, 고객명, 신용카드한도액을 출력해주세요.
SELECT C.CUSTOMER_ID 
	, C.NAME 
	, C.CREDIT_LIMIT 
FROM CUSTOMERS c 
;

-- 고객 테이블에서 고객 아이디, 고객명,주소, 웹사이트, 신용카드한도금액을 출력해주세요.
SELECT c.CUSTOMER_ID 
	, c.NAME 
	, c.ADDRESS 
	, c.WEBSITE 
	, c.CREDIT_LIMIT 
FROM CUSTOMERS c 
;

-- 고객 테이블에 존재하는 모든 컬럼의 값을 출력하시오.
SELECT *
FROM CUSTOMERS
;

-- 오라클에서 제공하는 DUAL 테이블을 조회하시오.
SELECT *
FROM DUAL 
;

-- DUAL 테이블을 이용하여 SELECT 절에서 연산 처리 가능함
SELECT 
	(10 + 5) / 2 AS VALUE
FROM DUAL 
;

-- ORDER BY 문 
/*
 * - 디폴트가 ASC (오름차순)
 * - 내림차순 : DESC       
 */
SELECT C.CUSTOMER_ID 
	, C.NAME 
	, C.CREDIT_LIMIT 
FROM CUSTOMERS c 
ORDER BY NAME  
;

SELECT C.CUSTOMER_ID 
	, C.NAME 
	, C.CREDIT_LIMIT 
FROM CUSTOMERS c 
ORDER BY NAME DESC   
;

SELECT FIRST_NAME 
	, LAST_NAME 
FROM CONTACTS 
ORDER BY FIRST_NAME, LAST_NAME DESC  
;

-- SELECT DISTINCT 문 
-- 전체 결과 건수 319건
SELECT FIRST_NAME 
FROM CONTACTS c 
ORDER BY FIRST_NAME 
;

-- 중복된 FIRST_NAME 값이 제거됨
-- 전체 결과 건수 302건 
SELECT 
	DISTINCT FIRST_NAME 
FROM CONTACTS c 
ORDER BY FIRST_NAME 
;

-- PRODUCT_ID와 QUANTITY 칼럼 값 기준으로 유일한 집합을 출력하시오.(ORDER_ITEMS) 665  / 657
SELECT DISTINCT PRODUCT_ID 
	, QUANTITY 
FROM ORDER_ITEMS oi 
ORDER BY PRODUCT_ID 
;


SELECT 
		p.PRODUCT_NAME 
	,	p.DESCRIPTION 
	,	p.LIST_PRICE 
	,	p.CATEGORY_ID 
FROM PRODUCTS p 
WHERE p.PRODUCT_NAME = 'Kingston'
;

-- LIST_PRICE가 500을 초과하는 행(들)을 출력하시오.
SELECT P.PRODUCT_NAME 
	, P.LIST_PRICE 
FROM PRODUCTS p 
WHERE P.LIST_PRICE > 500
;

-- LIST_PRICE가 500을 초과하고 CATEGORY_ID가 4인 행(들)을 출력하시오. 
-- (PRODUCT_NAME, LIST_PRICE, CATEGORY_ID )
SELECT P.PRODUCT_NAME 
	, P.LIST_PRICE 
	, P.CATEGORY_ID 
FROM PRODUCTS p 
WHERE P.LIST_PRICE > 500 
AND P.CATEGORY_ID = 4
;


-- LIST_PRICE가 650 이상이면서 680 이하인 행(들)을 출력해 주세요.
SELECT P.PRODUCT_NAME 
	, P.LIST_PRICE 
FROM PRODUCTS p 
WHERE P.LIST_PRICE BETWEEN 650 AND 680
ORDER BY LIST_PRICE 
;

SELECT P.PRODUCT_NAME 
	, P.LIST_PRICE 
FROM PRODUCTS p 
WHERE P.LIST_PRICE >= 650 AND P.LIST_PRICE <= 680
ORDER BY LIST_PRICE 
;

-- CATEGORY_ID가 1 혹은 4일 행(들)을 출력하시오.
SELECT P.PRODUCT_NAME 
	, P.CATEGORY_ID 
FROM PRODUCTS p 
WHERE CATEGORY_ID IN(1, 4)
ORDER BY P.PRODUCT_NAME 
;

SELECT P.PRODUCT_NAME 
	, P.CATEGORY_ID 
FROM PRODUCTS p 
WHERE CATEGORY_ID = 1 OR CATEGORY_ID = 4
ORDER BY P.PRODUCT_NAME 
;

-- PRODUCT_NAME이 'Asus'로 시작하는 행(들)을 출력하시오.
SELECT P.PRODUCT_NAME 
	, P.LIST_PRICE 
FROM PRODUCTS p 
WHERE PRODUCT_NAME LIKE 'Asus%'
ORDER BY P.LIST_PRICE 
;

-- INSERT문
-- 테이블 생성 
DROP TABLE DISCOUNTS PURGE;

CREATE TABLE DISCOUNTS
(
	DISCOUNT_ID	NUMBER GENERATED BY DEFAULT AS IDENTITY 
	, DISCOUNT_NAME VARCHAR2(255) NOT NULL 
	, AMOUNT NUMBER(3, 1) NOT NULL 
	, START_DATE DATE NOT NULL 
	, EXPIRED_DATE DATE NOT NULL 
);


-- 데이터 삽입 
INSERT INTO 
	DISCOUNTS A (
					A.DISCOUNT_NAME 
					, A.AMOUNT 
					, A.START_DATE 
					, A.EXPIRED_DATE 
			    )
	VALUES 		(
					'Autumn, Spring Promotion'
					, 9.5
					, DATE '2023-10-26'
					, DATE '2024-03-05'
				);
COMMIT;

SELECT * 
FROM DISCOUNTS d
;

-- 2번째 데이터 삽입 
INSERT INTO 
	DISCOUNTS A (
					A.DISCOUNT_NAME 
					, A.AMOUNT 
					, A.START_DATE 
					, A.EXPIRED_DATE 
			    )
	VALUES 		(
					'Winter Promotion'
					, 10.5
					, CURRENT_DATE
					, DATE '2023-12-31'
				);
COMMIT;

-- 테이블 생성
CREATE TABLE PARTS
(
	PART_ID NUMBER GENERATED BY DEFAULT AS IDENTITY 
	, PART_NAME VARCHAR(50) NOT NULL 
	, LEAD_TIME NUMBER(2,0) NOT NULL 
	, COST NUMBER(9,2) NOT NULL 
	, STATUS NUMBER (1,0) NOT NULL
	, PRIMARY KEY (PART_ID)
);

-- 데이터 입력
INSERT INTO PARTS (PART_NAME,LEAD_TIME,COST,STATUS) VALUES ('sed dictum',5,134,0);
INSERT INTO PARTS (PART_NAME,LEAD_TIME,COST,STATUS) VALUES ('tristique neque',3,62,1);
INSERT INTO PARTS (PART_NAME,LEAD_TIME,COST,STATUS) VALUES ('dolor quam,',16,82,1); 
INSERT INTO PARTS (PART_NAME,LEAD_TIME,COST,STATUS) VALUES ('nec, diam.',41,10,1); 
INSERT INTO PARTS (PART_NAME,LEAD_TIME,COST,STATUS) VALUES ('vitae erat',22,116,0); 
INSERT INTO PARTS (PART_NAME,LEAD_TIME,COST,STATUS) VALUES ('parturient montes,',32,169,1);
INSERT INTO PARTS (PART_NAME,LEAD_TIME,COST,STATUS) VALUES ('metus. In',45,88,1); 
INSERT INTO PARTS (PART_NAME,LEAD_TIME,COST,STATUS) VALUES ('at, velit.',31,182,0); 
INSERT INTO PARTS (PART_NAME,LEAD_TIME,COST,STATUS) VALUES ('nonummy ultricies',7,146,0); 
INSERT INTO PARTS (PART_NAME,LEAD_TIME,COST,STATUS) VALUES ('a, dui.',38,116,0); 
INSERT INTO PARTS (PART_NAME,LEAD_TIME,COST,STATUS) VALUES ('arcu et',37,72,1); 
INSERT INTO PARTS (PART_NAME,LEAD_TIME,COST,STATUS) VALUES ('sapien. Cras',40,197,1); 
INSERT INTO PARTS (PART_NAME,LEAD_TIME,COST,STATUS) VALUES ('et malesuada',24,46,0); 
INSERT INTO PARTS (PART_NAME,LEAD_TIME,COST,STATUS) VALUES ('mauris id',4,153,1);
INSERT INTO PARTS (PART_NAME,LEAD_TIME,COST,STATUS) VALUES ('eleifend egestas.',2,146,0); 
INSERT INTO PARTS (PART_NAME,LEAD_TIME,COST,STATUS) VALUES ('cursus. Nunc',9,194,1); 
INSERT INTO PARTS (PART_NAME,LEAD_TIME,COST,STATUS) VALUES ('vivamus sit',37,93,0);
INSERT INTO PARTS (PART_NAME,LEAD_TIME,COST,STATUS) VALUES ('ac orci.',35,134,0); 
INSERT INTO PARTS (PART_NAME,LEAD_TIME,COST,STATUS) VALUES ('arcu. Aliquam',36,154,0); 
INSERT INTO PARTS (PART_NAME,LEAD_TIME,COST,STATUS) VALUES ('at auctor',32,56,1); 
INSERT INTO PARTS (PART_NAME,LEAD_TIME,COST,STATUS) VALUES ('purus, accumsan',33,12,1);
COMMIT;
/*
 ('dolor quam,',16,82,1); 
 ('nec, diam.',41,10,1); 
 ('vitae erat',22,116,0); 
 ('parturient montes,',32,169,1); 
 ('metus. In',45,88,1); 
 ('at, velit.',31,182,0); 
 ('nonummy ultricies',7,146,0); 
 ('a, dui.',38,116,0); 
 ('arcu et',37,72,1); 
 ('sapien. Cras',40,197,1); 
 ('et malesuada',24,46,0); 
 ('mauris id',4,153,1); 
 ('eleifend egestas.',2,146,0); 
 ('cursus. Nunc',9,194,1); 
 ('vivamus sit',37,93,0); 
 ('ac orci.',35,134,0); 
 ('arcu. Aliquam',36,154,0); 
 ('at auctor',32,56,1); 
 ('purus, accumsan',33,12,1);
 */

SELECT *
FROM PARTS p
ORDER BY PART_ID 
;

UPDATE PARTS 
	SET COST = 130
 WHERE PART_ID = 1
;

SELECT * 
FROM PARTS p 
WHERE PART_ID = 1
;

UPDATE PARTS 
	SET LEAD_TIME = 30
	, COST = 120
	, STATUS = 0
 WHERE PART_ID = 5
 ;

SELECT * 
FROM PARTS p 
WHERE PART_ID = 5
;

-- 전체 행 업데이트 
-- WHERE 절이 없는 UPDATE문은 매우 위험한 작업이므로 경고창 뜸 
UPDATE PARTS 
	SET COST = COST * 1.05
;

CREATE TABLE SALES
AS
SELECT
		A.ORDER_ID 
		, B.ITEM_ID 
		, B.PRODUCT_ID 
		, B.QUANTITY 
		, B.UNIT_PRICE 
		, A.STATUS 
		, A.ORDER_DATE 
		, A.SALESMAN_ID 
	FROM ORDERS A
		,ORDER_ITEMS B
	WHERE A.ORDER_ID = B.ORDER_ID 
;

SELECT *
FROM SALES s 
;

-- 데이터 삭제
DELETE 
FROM SALES s 
WHERE ORDER_ID = 1
AND ITEM_ID = 1
;

SELECT *
FROM SALES s 
WHERE ORDER_ID = 1
AND ITEM_ID = 1
;

SELECT *
FROM SALES s 
WHERE ORDER_ID = 1
;

DELETE 
FROM SALES s 
WHERE ORDER_ID =1
;

DELETE 
FROM SALES s 
;
















